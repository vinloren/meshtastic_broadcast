# meshtastic_broadcast
Since December 2020 I have been following the Meshtastic project which aims to create a communication network on 868Mhz band with devices based on ESP32 and LoRa radio (eg: TTGO-LoRa32-oled). The project includes communication support via Python on a serial interface connected to a PC. Through the Python meshtastic library it is possible to instruct the unit connected to the USB port to transmit and receive messages from the configured mesh. The python application described here aims to collect the protocol and data transmission messages by showing them on PythonQt5 GUI and saving them in Excel sheet for subsequent analysis.

## broadcast_msg_pyq5.py
It is the pyhon application with Qt5 GUI which aims to show all the messages that occur in the mesh detected by the node connected to the USB port of the host PC. The connection to the node is managed by the meshtastic library present in python environment having previously run 'pip install meshtastic' (without quotes) which provides the python API as described at https://github.com/meshtastic/Meshtastic-python

Through the GUI interface it is possible to manage the recording of the msgs exchanged in mesh with or without periodic sending, every 2 minutes, of the message present in the EditText input (which is automatically headed by the message name and time). This option is activated by the explanatory checkbox. If the checkbox is marked, only the automatic messages generated by the node with any replies are recorded, otherwise, in addition to these, the messages with the text present in the EditText box are sent.

The second checkbox present is used to possibly record all the messages that have occurred in the mesh on .csv file in order to obtain an excel file to be analyzed later. By marking the checkbox, the meshtastic_data.csv file is opened for writing. The recording continues until we uncheck the checkbox again (the mark is removed), at which time the .csv file is closed and the related data is available for excel processing. Each time the file is reopened it is reinitialized from the beginning.

In addition to displaying the messages that occurred in the mesh in tab1 widget (under label "Messages"), this application also shows all the nodes connected in the mesh with geographic coordinates, distance and bearing from the home point (the geo point of the node connected to the PC) , rxSnr and battery level if present. These data are in tab2 under "Connected" label.

## OpenStreet Map of mesh nodes
I added a further Tab (tab3 "GeoMap") to show the map with the Home position in the center shown in the QLineEdit field in "Home lat" and "Home lon" marked with blue markers and then the red markers for each detected node in mesh.

To create the map I used python folium called by PyQt5 QtWidgets, QtWebEngineWidgets then to show it I placed a QPushButton ("SHOW MAP") next to the home position references described above. The problem that arises is that of dynamically showing all the new markers that must gradually be inserted according to the new POSITION_APP acquisitions detected in the mesh. Once the map is shown new markers cannot be applied due to thread protection problems and it is therefore necessary to generate a new map every time in the same PyQt5 thread. I then had to find a solution with a PushButton that calls for the destruction of the previous map or the destruction of tab3 and its reconstruction with a new map that shows all the detected nodes. The nodes detected with their characteristics are visible in Tab2 and therefore it is easy to identify the moment in which it is appropriate to show the new map.

I chose the python folium solution because it seems to me well done and satisfactory; the alternative would have been to create a web page with OpenLayer 3.0 and all the related management javascript and then a python web socket server would also have been necessary to interface between the webtastic Python API protocol and the aforementioned web page to access the maps OpenStreet.

## History of connections over time
The summary data updated to the last contact node by node are shown in the table in Tab 2 and can be viewed on geomap in Tab 3, the dynamic data of each connection are also simultaneously saved in Sqlite3 DB (meshDB.db) in the directory hosting the python application. I added a radio button next to the "SHOW MAP" button that allows you to show on geomap the history of the connections you have over time, which can be selected by choosing the day we want between the minimum and maximum dates, instead of showing the momentary summary status.

## How are the markers of the geo coordinates of the nodes in the mesh are placed
There is a python dictionary in memory with the dynamic data of each meshed node originating from NODEINFO_APP messages. For each POSITION_APP message received by the nodes, the corresponding dictionary identified according to the 'from_id' key is updated with the relative geo data as well as with the value 'snr'. The updated dictionary css√¨ is written in Sqlite3 DB meshDB.db at each new NODEINFO_APP so that if you mark the radio button 'Day log' and then click the "SHOW MAP" button you will have the representation on the map of all the points reached from the nodes on the chosen day. The number of points represented on the map in this case will be equal to the number of POSITION_APP messages received by each node in the mesh (one every 5 minutes for my 2 nodes because they are so configured, the default is every 20 minutes).

If the radio button is not selected, SHOW MAP will show the geographical points of the various nodes in the mesh as per the table in the central Tab, i.e. the current position of each.

## Folium installation
A python 3.7 or higher installation must exist:

pip install pyqt5
pip install pyqtwebengine
pip install folium concludes the requirements

## Sending mesh data to MQTT server
On 03/18/21 I added two python programs to make sure that the dynamic data detected in the mesh are sent to MQTT server (broker.emqx.io) so that whoever subscribes to that server on the 'meshtastic / vinloren 'can see in real time all active nodes on the' vinloren 'mesh through the use of mqtt_subscribe.py.

### mqtt_send.py
mqtt_send.py transmits either the records being created on the current day or all the data already recorded in the DB starting from a date or between two selected dates. The data is published on brocker.emx.io which provides the publish service for free so that anyone who connects to it will be able to view the mesh data published in real time. The publication cadence is set at 375 seconds or the 'beacon' period (periodic communication of the GPS position) configured on all nodes of my mesh ('vinloren' mesh).

### mqtt_subscribe.py
this program allows you to view on the table all the data of the nodes that speak or have spoken in the selected mesh ('vinloren' in my case). The data shown in the table appear only once (the last one present) if the position of the relevant node has not changed by more than 10m, otherwise the data of that node will appear for each major change in position. In this way we have the tracking of the nodes in motion. All of this can be viewed on the geographic map in Tab 2 ('Map').

### Note
The program has been tested with meshtastic Python API 1.1.50 and node firmware 1.1.50 and then subsequently updated to support the new 1.2.xx environment (latest update verified 1.2.17) 
